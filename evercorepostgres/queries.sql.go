// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package evercorepostgres

import (
	"context"
	"database/sql"
	"time"
)

const addAggregate = `-- name: AddAggregate :one

INSERT INTO aggregates (aggregate_type_id) VALUES ($1) 
	RETURNING id
`

// Aggregate Queries
func (q *Queries) AddAggregate(ctx context.Context, aggregateTypeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, addAggregate, aggregateTypeID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addAggregateType = `-- name: AddAggregateType :one

INSERT INTO aggregate_types (name) VALUES ($1) 
	RETURNING id
`

// Aggregate Type Queries
func (q *Queries) AddAggregateType(ctx context.Context, aggregateTypeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, addAggregateType, aggregateTypeName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addAggregateWithNaturalKey = `-- name: AddAggregateWithNaturalKey :one
INSERT INTO aggregates (aggregate_type_id, natural_key) VALUES($1, $2) 
	RETURNING id
`

type AddAggregateWithNaturalKeyParams struct {
	AggregateTypeID int64
	NaturalKey      sql.NullString
}

func (q *Queries) AddAggregateWithNaturalKey(ctx context.Context, arg AddAggregateWithNaturalKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addAggregateWithNaturalKey, arg.AggregateTypeID, arg.NaturalKey)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addEvent = `-- name: AddEvent :exec

INSERT INTO events (aggregate_id, sequence, event_type_id, state, event_time, reference)
	VALUES(
		$1, 
		$2,
		$3, 
		$4,
		$5,
		$6
	)
`

type AddEventParams struct {
	AggregateID int64
	Sequence    int64
	EventTypeID int64
	State       string
	EventTime   time.Time
	Reference   string
}

// Event Queries
func (q *Queries) AddEvent(ctx context.Context, arg AddEventParams) error {
	_, err := q.db.ExecContext(ctx, addEvent,
		arg.AggregateID,
		arg.Sequence,
		arg.EventTypeID,
		arg.State,
		arg.EventTime,
		arg.Reference,
	)
	return err
}

const addEventType = `-- name: AddEventType :one

INSERT INTO event_types (name) VALUES($1)
	RETURNING id
`

// Event Type Queries
func (q *Queries) AddEventType(ctx context.Context, eventName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, addEventType, eventName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addSnapshot = `-- name: AddSnapshot :exec
INSERT INTO snapshots (aggregate_id, sequence, state) VALUES($1, $2, $3)
`

type AddSnapshotParams struct {
	AggregateID int64
	Sequence    int64
	State       string
}

func (q *Queries) AddSnapshot(ctx context.Context, arg AddSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, addSnapshot, arg.AggregateID, arg.Sequence, arg.State)
	return err
}

const getAggregateById = `-- name: GetAggregateById :one
SELECT id, natural_key FROM aggregates WHERE aggregate_type_id=$1 AND id=$2
`

type GetAggregateByIdParams struct {
	AggregateTypeID int64
	AggregateID     int64
}

type GetAggregateByIdRow struct {
	ID         int64
	NaturalKey sql.NullString
}

func (q *Queries) GetAggregateById(ctx context.Context, arg GetAggregateByIdParams) (GetAggregateByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getAggregateById, arg.AggregateTypeID, arg.AggregateID)
	var i GetAggregateByIdRow
	err := row.Scan(&i.ID, &i.NaturalKey)
	return i, err
}

const getAggregateIdByNaturalKey = `-- name: GetAggregateIdByNaturalKey :one
SELECT id FROM aggregates WHERE aggregate_type_id=$1 and natural_key=$2
`

type GetAggregateIdByNaturalKeyParams struct {
	AggregateTypeID int64
	NaturalKey      sql.NullString
}

func (q *Queries) GetAggregateIdByNaturalKey(ctx context.Context, arg GetAggregateIdByNaturalKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAggregateIdByNaturalKey, arg.AggregateTypeID, arg.NaturalKey)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAggregateTypeIdByName = `-- name: GetAggregateTypeIdByName :one
SELECT id FROM aggregate_types WHERE name=$1
`

func (q *Queries) GetAggregateTypeIdByName(ctx context.Context, aggregateTypeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAggregateTypeIdByName, aggregateTypeName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAggregateTypes = `-- name: GetAggregateTypes :many
SELECT id, name FROM aggregate_types
`

func (q *Queries) GetAggregateTypes(ctx context.Context) ([]AggregateType, error) {
	rows, err := q.db.QueryContext(ctx, getAggregateTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggregateType
	for rows.Next() {
		var i AggregateType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTypeIdByName = `-- name: GetEventTypeIdByName :one
SELECT id FROM event_types WHERE name=$1
`

func (q *Queries) GetEventTypeIdByName(ctx context.Context, eventName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEventTypeIdByName, eventName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getEventTypes = `-- name: GetEventTypes :many
SELECT id, name FROM event_types
`

func (q *Queries) GetEventTypes(ctx context.Context) ([]EventType, error) {
	rows, err := q.db.QueryContext(ctx, getEventTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventType
	for rows.Next() {
		var i EventType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForAggregate = `-- name: GetEventsForAggregate :many
SELECT sequence, et.name event_type, state, event_time, reference
FROM events e
JOIN event_types AS et ON e.event_type_id = et.id
WHERE e.aggregate_id = $1 AND sequence > $2 
ORDER BY sequence
`

type GetEventsForAggregateParams struct {
	AggregateID   int64
	AfterSequence int64
}

type GetEventsForAggregateRow struct {
	Sequence  int64
	EventType string
	State     string
	EventTime time.Time
	Reference string
}

func (q *Queries) GetEventsForAggregate(ctx context.Context, arg GetEventsForAggregateParams) ([]GetEventsForAggregateRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsForAggregate, arg.AggregateID, arg.AfterSequence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsForAggregateRow
	for rows.Next() {
		var i GetEventsForAggregateRow
		if err := rows.Scan(
			&i.Sequence,
			&i.EventType,
			&i.State,
			&i.EventTime,
			&i.Reference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentSnapshot = `-- name: GetMostRecentSnapshot :one
SELECT aggregate_id, sequence, state
FROM snapshots
WHERE aggregate_id=$1 
ORDER BY sequence DESC
LIMIT 1
`

type GetMostRecentSnapshotRow struct {
	AggregateID int64
	Sequence    int64
	State       string
}

func (q *Queries) GetMostRecentSnapshot(ctx context.Context, aggregateID int64) (GetMostRecentSnapshotRow, error) {
	row := q.db.QueryRowContext(ctx, getMostRecentSnapshot, aggregateID)
	var i GetMostRecentSnapshotRow
	err := row.Scan(&i.AggregateID, &i.Sequence, &i.State)
	return i, err
}
